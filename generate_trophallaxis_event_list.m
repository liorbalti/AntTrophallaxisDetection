function unified_events = generate_trophallaxis_event_list(BBoxes,Scores,bugtag_data,roiRect,outfile)
% GENERATE_TROPHALLAXIS_EVENT_LIST - creates a list of trophallactic events.
% Using the frame-by-frame interaction detection data generated by the
% function 'detect_trophallaxis', and location data based on the ants' tags,
% this function concatenates consecutive and overlapping detections to create
% a list of whole trophallaxis events.
%
% Syntax:  event_table = generate_trophallaxis_event_list(BBoxes,Scores,bugtag_data,roiRect,outfile)
%
% Inputs:
%   BBoxes      - a cell array of bounding boxes indicating the posititions
%                 of detected trophallaxis. Generated by the function
%                 'detect_trophallaxis'.
%   Scores      - a cell array of scores of detected trophallaxis.
%                 Generated by the function 'detect_trophallaxis'.
%   bugtag_data - a table containing location data of ants, generated by
%                 the bugtag program. Each row of the table corresponds to
%                 one frame in the video. For each tag 'a' there are 4
%                 columns named 'a-x','a-y','a-angle' and 'a-error',
%                 corresponding to the x coordinate, y coordinate, heading
%                 angle, and detection certainty (0-best, 5-worst) of the
%                 tag, respectively. Tags that were not detected in a frame
%                 get '-1' in all columns.
%                 In addition, the two first columns are 'frame #' and
%                 'recognitions', indicating the number of the frame, and
%                 the total number of recognized tags in that frame.
%   roiRect     - a 4-element numeric vector indicating the size and position of
%                 the ROI in which to search for trophallaxes, in the form
%                 [xmin ymin width height]. Generated by the function
%                 'get_roi_for_trophallaxis_detection'.
%   outfile     - a string of the name of the file to which the output will
%                 be saved.
%
% Outputs:
%   event_table - a table containing information on the detected
%                 trophallaxis events. Each row corresponds to a single
%                 detected event.
%                 Columns:
%                   id - serial identification number for the event
%                   locations   - x and y coordinates of the centroid of the
%                                 dedected event
%                   start_frame - first frame the event was detected
%                   end_frame   - last frame the event was detected
%                   max_score   - the maximal detection score of all detected
%                                 instances of the event
%                   ant_1       - the id of the most frequently-detected ant 
%                                 near the event location during the event. 
%                                 NaN if no ants were detected near the event.
%                   ant_2       - the id of the second most frequently-detected 
%                                 ant near the event location during the event.
%                                 NaN if less than two ants were detected
%                                 near the event.
%
% Other m-files required: unify_events_by_location_and_ants.m
% Subfunctions: find_ants_around_detections, get_candidate_ants_for_bbox,
%               get_event_ants, pick_first_two
%


%------------- BEGIN CODE --------------

ghost_life = 3; % number of frames allowed for missing detections and still count as the same event.
dist_thres = 200; % distance between tag and centroid of detection to consider candidate ants

ants = find_ants_around_detections(bugtag_data, dist_thres, BBoxes, roiRect);

% initialize variables for storing event data
event_id{1} = (1:size(BBoxes{1},1))';
all_event_ids = event_id{1};
all_event_bboxes = BBoxes{1};
all_event_locations = [all_event_bboxes(:,1)+all_event_bboxes(:,3)./2,...
    all_event_bboxes(:,2)+all_event_bboxes(:,4)./2];  % centroids
all_ants_cell = cell(size(BBoxes{1},1),1);
start_frame = zeros(length(all_event_ids),1);
end_frame = [];
ghost_bboxes = [];
ghost_ids = [];
ghost_ages = [];
dead_ghosts = [];
all_scores_cell = mat2cell(Scores{1},ones(length(Scores{1}),1));
all_bboxes_cell = mat2cell(BBoxes{1},ones(size(BBoxes{1},1),1));


for f = 1:(length(BBoxes)-1) % for each frame
    
    % advance ghosts age
    ghost_ages = ghost_ages+1;
    dead_ghosts = ghost_ages>ghost_life;
    
    % remove dead ghosts
    if any(dead_ghosts)
        
        end_frame(ismember(all_event_ids,ghost_ids(dead_ghosts)),1)=f-ghost_life-1;
        
        ghost_ids(dead_ghosts)=[];
        ghost_bboxes(dead_ghosts,:)=[];
        ghost_ages(dead_ghosts)=[];
    end
    
    % add living ghosts to intersection search
    bboxes_f_and_ghosts = [BBoxes{f}; ghost_bboxes];
    ids_f_and_ghosts = [event_id{f}; ghost_ids];
    
    % find intersecting bounding boxes
    intersections = rectint(bboxes_f_and_ghosts,BBoxes{f+1});
    
    % assign event id by intersections
    [loc1, loc2] = find(intersections);
    event_id{f+1,1} = (1:size(BBoxes{f+1},1))'+max([max(all_event_ids), 0]);
    event_id{f+1,1}(loc2) = ids_f_and_ghosts(loc1);
    
    % add new events to list
    [new_event_ids, new_event_locs] = setdiff(event_id{f+1},all_event_ids,'stable');
    to_subtract_from_new_id = cumsum(ismember(event_id{f+1},all_event_ids));
    new_event_ids = new_event_ids-to_subtract_from_new_id(new_event_locs);
    event_id{f+1}(new_event_locs) = new_event_ids;
    if any(new_event_locs)
        new_event_bboxes = BBoxes{f+1}(new_event_locs,:);
        new_event_locations = [new_event_bboxes(:,1)+new_event_bboxes(:,3)./2,...
            new_event_bboxes(:,2)+new_event_bboxes(:,4)./2]; % centroids
        all_event_ids = [all_event_ids; new_event_ids];
        all_event_bboxes = [all_event_bboxes; new_event_bboxes];
        all_event_locations = [all_event_locations; new_event_locations];
        start_frame = [start_frame; f*ones(length(new_event_ids),1)];
        for ee = new_event_ids'
            all_scores_cell{ee,1} = [];
            all_bboxes_cell{ee,1} = [];
            all_ants_cell{ee,1} = [];
        end
    end
    
    % store event scores and bounding boxes
    if ~isempty(event_id{f+1})
        for ee = event_id{f+1}'
            all_scores_cell{ee} = [all_scores_cell{ee}; Scores{f+1}(event_id{f+1}==ee)];
            all_bboxes_cell{ee} = [all_bboxes_cell{ee}; BBoxes{f+1}(event_id{f+1}==ee,:)];
            all_ants_cell{ee} = [all_ants_cell{ee};...
                cell2mat(cellfun(@(x) x(:),ants{f+1}(event_id{f+1}==ee),'uni',false))];
        end
    end
    
    % remove returned ghosts from ghost list
    returned_ghosts = ismember(ghost_ids,event_id{f+1});
    if any(returned_ghosts)
        ghost_ids(returned_ghosts)=[];
        ghost_bboxes(returned_ghosts,:)=[];
        ghost_ages(returned_ghosts)=[];
    end
    
    % add new ghosts
    [new_ghosts_ids, new_ghosts_loc] = setdiff(event_id{f},event_id{f+1},'stable');
    if any(new_ghosts_loc)
        new_ghost_bboxes = BBoxes{f}(new_ghosts_loc,:);
        ghost_ids = [ghost_ids; new_ghosts_ids];
        ghost_bboxes = [ghost_bboxes; new_ghost_bboxes];
        ghost_ages = [ghost_ages; zeros(size(new_ghosts_ids))];
    end
end

end_frame(event_id{end}) = length(event_id);
end_frame(ghost_ids) = length(event_id)-ghost_ages-1;
if size(end_frame,2)>1
    end_frame = end_frame';
end

% find the two closest ants to each event
event_ants = get_event_ants(all_ants_cell);

% generate event table
event_table = table();
event_table.id = all_event_ids; % serial number of event
event_table.locations = all_event_locations; % x and y coordinates of event in frame
event_table.start_frame = start_frame;
event_table.end_frame = end_frame;
event_table.max_score = cellfun(@max, all_scores_cell);
event_table.ant1 = event_ants(:,1);
event_table.ant2 = event_ants(:,2);

% merge events if they overlap spatially, include the same 2 ants, and none
% of the two ants was detected far from the event location throughout the
% duration of the merged event.
unified_events = unify_events_by_location_and_ants(event_table, bugtag_data, 1000, roiRect);

% save table
writetable(unified_events,outfile)
end


%%
function ants = find_ants_around_detections(tag_data, dist_thres, BBoxes, roiRect)
% for each detection in each frame, get ant IDs that are close to the detection

ant_list = cellfun(@(x) str2double(regexp(x, '\d*', 'Match')), tag_data.Properties.VariableNames(3:4:end));

ants = {};
for f = 1:length(BBoxes) % for each frame
    
    frame_bboxes = BBoxes{f};
    tag_frame_data = tag_data(f,:);
    
    ants_frame = {};
    for s = 1:size(frame_bboxes,1)  % for each detection
        ants_bbox = get_candidate_ants_for_bbox(frame_bboxes(s,:), tag_frame_data, ant_list, dist_thres, roiRect);
        ants_frame = [ants_frame; {ants_bbox}];
    end
    ants = [ants; {ants_frame}];
end

end

%%
function ants_bbox = get_candidate_ants_for_bbox(bbox, bugtag_frame_data, ant_list, dist_thres, roiRect)

% arrange tag data
bugtag_frame_mat = reshape(bugtag_frame_data{:,3:end},[4,length(ant_list)])';
bugtag_frame_mat(bugtag_frame_mat==-1)=nan;  % -1 indicates tag that is not detected
bugtag_frame_table = array2table(bugtag_frame_mat, 'VariableNames',{'x','y','angle','error'});

% get bbox centroid
bbox_centroid_x = bbox(1)+bbox(3)/2;
bbox_centroid_y = bbox(2)+bbox(4)/2;

% account for ROI cropping in detection (tag data coordinates refer to the full frame)
cropped_x = bugtag_frame_table.x-roiRect(1);
cropped_y = bugtag_frame_table.y-roiRect(2);

% get ant ids that are close enough to the detection
distances = sqrt((cropped_x-bbox_centroid_x).^2+(cropped_y-bbox_centroid_y).^2);
ants_bbox = ant_list(distances<=dist_thres);

end

%%
function event_ants = get_event_ants(all_ants_cell)
% of all candidate ant IDs, take the two most frequently detected ants

[uniques, ~, ics] = cellfun(@unique, all_ants_cell,'uni',false);
unique_counts = cellfun(@(x) accumarray(x,1), ics, 'uni',false);
unique_and_counts = cellfun(@(x,y) [x,y], uniques, unique_counts,'uni',false);
sorted = cellfun(@(x) sortrows(x,2,'descend'), unique_and_counts,'uni',false);
event_ants_cell = cellfun(@pick_first_two,sorted,'uni',false);
event_ants = cell2mat(event_ants_cell);
end

%%
function top_ants =  pick_first_two(sorted)

switch size(sorted,1)
    case 1 % if only one candidate found, second ant is NaN
        top_ants = [sorted(1,1), nan];
    case 0 % if no candidates found, both ants are NaN
        top_ants = nan(1,2);
    otherwise % if more than one candidate found, take top two
        top_ants = sorted(1:2,1)';
end


end
%------------- END OF CODE --------------