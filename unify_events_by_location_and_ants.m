function unified_events = unify_events_by_location_and_ants(event_table, tag_info, distance_thres, roiRect)
%UNIFY_EVENTS_BY_LOCATION_AND_ANTS - merges events in event list according to the following criteria:
% 1. the events overlap spatially
% 2. the events include the same 2 ants
% 3. none of the two event ants was detected far from the event location 
%    throughout the duration of the merged event.
%
%
% Syntax:  unified_events = unify_events_by_location_and_ants(event_table, tag_info, distance_thres, crop_rect)
%
% Inputs:
%   event_table - a table containing information on the detected
%                 trophallaxis events. Each row corresponds to a single
%                 detected event.
%                 Columns:
%                   id - serial identification number for the event
%                   locations   - x and y coordinates of the centroid of the
%                                 dedected event
%                   start_frame - first frame the event was detected
%                   end_frame   - last frame the event was detected
%                   max_score   - the maximal detection score of all detected
%                                 instances of the event
%                   ant_1       - the id of the most frequently-detected ant 
%                                 near the event location during the event. 
%                                 NaN if no ants were detected near the event.
%                   ant_2       - the id of the second most frequently-detected 
%                                 ant near the event location during the event.
%                                 NaN if less than two ants were detected
%                                 near the event.
%   tag_info   - a table containing location data of ants, generated by
%                the bugtag program. Each row of the table corresponds to
%                one frame in the video. For each tag 'a' there are 4
%                columns named 'a-x','a-y','a-angle' and 'a-error',
%                corresponding to the x coordinate, y coordinate, heading
%                angle, and detection certainty (0-best, 5-worst) of the
%                tag, respectively. Tags that were not detected in a frame
%                get '-1' in all columns.
%   distance_thres - an integer indicating the distance (in pixels) between 
%                tag and centroid of detection above which ants are considered 
%                to be far from event location
%   roiRect    - a 4-element numeric vector indicating the size and position of
%                the ROI in which to search for trophallaxes, in the form
%                [xmin ymin width height]. Generated by the function
%                'get_roi_for_trophallaxis_detection'.
%
% Outputs:
%    unified_events - Description
%
% 
% Subfunctions: filter_events_to_unite_by_tag_info, get_gaps, unify_events
% 
%------------- BEGIN CODE --------------

% get squares around centroids of detections
x = event_table.locations(:,1)-174/2;
y = event_table.locations(:,2)-174/2;
w = 175*ones(height(event_table),1);
Squares = [x,y,w,w];

% ids of ants in each event
ants = [event_table.ant1, event_table.ant2];

% find spatially overlapping events
intersection_mat = triu(rectint(Squares, Squares));
intersection_mat = intersection_mat-diag(diag(intersection_mat));
[ii,jj] = ind2sub(size(intersection_mat),find(intersection_mat>0));

% get ant ids of spatially overlapping events
ants_ii = ants(ii,:);
ants_jj = ants(jj,:);

% find which of the overlapping events share the same two ants
ants_ii_cell = mat2cell(ants_ii,ones(1,size(ants_ii,1)));
ants_jj_cell = mat2cell(ants_jj,ones(1,size(ants_jj,1)));
same_ants = cellfun(@(x,y) sum(ismember(x,y))==2, ants_ii_cell, ants_jj_cell);
same_ants_ii = ii(same_ants);
same_ants_jj = jj(same_ants);

% candidate events to unite are overlapping events that share the same 2 ants
events_to_unite = [event_table.id(same_ants_ii), event_table.id(same_ants_jj)];

if ~isempty(events_to_unite)
    % filter out candidate events in which at least one of the ants was
    % detected far from the event throughout the durating of the merged event
    filtered_event_ids_to_unite = filter_events_to_unite_by_tag_info(events_to_unite,event_table,tag_info,distance_thres, roiRect);
    
    % create event table with unified events
    row=1;
    for ee = unique(filtered_event_ids_to_unite)'
        events = event_table(filtered_event_ids_to_unite==ee,:);
        unified = unify_events(events,ee);
        unified_events(row,:) = unified;
        row = row+1;
    end
    
    unified_events = sortrows(unified_events,'start_frame');
    unified_events.id = (1:height(unified_events))';
else
    unified_events = event_table;
end

end

%%
function filtered = filter_events_to_unite_by_tag_info(events_to_unite,event_table,tag_info,distance_thres, crop_rect)
% Sets to unify only overlapping events that share the same two ants in durations
% when none of the two ants were detected far from the event

% assign grouped event ids
G = graph(events_to_unite(:,1),events_to_unite(:,2));
[grouped_event_id, counts] = G.conncomp;

% add last interactions from event_table
missing_grouped_event_ids = (1:(height(event_table)-length(grouped_event_id))) + max(grouped_event_id);
grouped_event_id = [grouped_event_id, missing_grouped_event_ids]';
counts = [counts'; ones(length(missing_grouped_event_ids),1)];

% adjust grouped event ids according to far detections
filtered = grouped_event_id;
for ii = 1:max(grouped_event_id)
    
    if counts(ii)>1
        events = event_table(grouped_event_id==ii,:);
        time_sorted = sortrows(events,'start_frame');
        
        gaps_frames = get_gaps(time_sorted);
        
        ants = unique([time_sorted.ant1, time_sorted.ant2]);
        
        far_detections=[];
        for ant = ants'
            x = tag_info.(['x' num2str(ant) '_x'])(gaps_frames)-crop_rect(1);
            y = tag_info.(['x' num2str(ant) '_y'])(gaps_frames)-crop_rect(2);
            er = tag_info.(['x' num2str(ant) '_error'])(gaps_frames);
            er(er<0)=[];
            x(x<0)=[];
            y(y<0)=[];
            
            too_far = sqrt((x-time_sorted.locations(1,1)).^2 + (y-time_sorted.locations(1,2)).^2)>distance_thres;
            
            far_detections = union(far_detections,gaps_frames(too_far & er<3));
        end
        
        
        if ~isempty(far_detections)
            
            disp(['Far detections grouped event ' num2str(ii)])
            
            % find in which gaps ant was detected far from event
            gaps_with_far_detections = unique(discretize(far_detections, time_sorted.start_frame));
            
            % split the events at each far detection
            event_ids = find(grouped_event_id==ii);
            split_event_ids = mat2cell(event_ids,diff([0,gaps_with_far_detections,length(event_ids)]),1);
            for s = 2:length(split_event_ids)
                filtered(split_event_ids{s})=max(filtered)+1;
            end
            
        end
        
    end


end

end

%%
function gaps_frames = get_gaps(time_sorted_events)

gaps_frames = [];
for ee = 2:height(time_sorted_events)
    gaps_frames = [gaps_frames, time_sorted_events.end_frame(ee-1):time_sorted_events.start_frame(ee)];
end


end

%%
function unified = unify_events(events_to_unify_table,grouped_id)

unified = events_to_unify_table(1,:);
unified.id = grouped_id;
unified.start_frame = min(events_to_unify_table.start_frame);
unified.end_frame = max(events_to_unify_table.end_frame);
unified.max_score = max(events_to_unify_table.max_score);

end
%------------- END OF CODE --------------